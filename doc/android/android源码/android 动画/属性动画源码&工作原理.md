#### 1.属性动画概述

**属性动画要求作用对象提供set和get方法,属性动画根据外界传递的该属性的初始值和最终值,以动画的效果多次去调用set方法,每次传递给set方法的值不一样,确切的说是随着时间的推移,所传递的值越来越接近最终值**



#### 2. `.start`开始动画

> `ObjectAnimator.ofInt(textView,"width",500).setDuration(5000).start();`

首先看`.start`

```java
// class #### ObjectAnimator
@Override
public void start() {
    AnimationHandler.getInstance().autoCancelBasedOn(this); // target1
    if (DBG) {
        Log.d(LOG_TAG, "Anim target, duration: " + getTarget() + ", " + getDuration());
        for (int i = 0; i < mValues.length; ++i) {
            PropertyValuesHolder pvh = mValues[i];
            Log.d(LOG_TAG, "   Values[" + i + "]: " +
                pvh.getPropertyName() + ", " + pvh.mKeyframes.getValue(0) + ", " +
                pvh.mKeyframes.getValue(1));
        }
    }
    super.start(); // target2
}
```

#### 3. `AnimationHandler.getInstance().autoCancelBasedOn(this)`cancel重复动画



首先看`target1` `AnimationHandler.getInstance().autoCancelBasedOn(this);`

```java
public static AnimationHandler getInstance() {
    if (sAnimatorHandler.get() == null) {
        sAnimatorHandler.set(new AnimationHandler());
    }
    return sAnimatorHandler.get();
}
```

这里的`sAnimatorHandler`就是`ThreadLocal`,**每个线程会持有一个`ThreadLocal.ThreadLocalMap`,然后通过所在线程get到这个map,然后通过当前`TreadLocal`的key.threadLocalHashCode去getEntry,获得value**

继续看`.autoCancelBasedOn`

```java
void autoCancelBasedOn(ObjectAnimator objectAnimator) {
    for (int i = mAnimationCallbacks.size() - 1; i >= 0; i--) {
        AnimationFrameCallback cb = mAnimationCallbacks.get(i);
        if (cb == null) {
            continue;
        }
        if (objectAnimator.shouldAutoCancel(cb)) {
            ((Animator) mAnimationCallbacks.get(i)).cancel();
        }
    }
}
```

这里就是check`当前动画`  `等待动画` `延迟动画`是否有与当前动画相同的,然后把相同的动画 `cancel`,接着是一部分log

之后调用父类的`super.start()`

#### 4.VauleAnimator-`start()`

```java
@Override
public void start() {
    start(false);
}

private void start(boolean playBackwards) {
        if (Looper.myLooper() == null) {
            throw new AndroidRuntimeException("Animators may only be run on Looper threads");
        }
        mReversing = playBackwards;  // 是否反转从后面开始播放
        mSelfPulse = !mSuppressSelfPulseRequested;
        // Special case: reversing from seek-to-0 should act as if not seeked at all.
        if (playBackwards && mSeekFraction != -1 && mSeekFraction != 0) {
            if (mRepeatCount == INFINITE) {
                // Calculate the fraction of the current iteration.
                float fraction = (float) (mSeekFraction - Math.floor(mSeekFraction));
                mSeekFraction = 1 - fraction;
            } else {
              	// 表示动画要跳到的播放时间点
                mSeekFraction = 1 + mRepeatCount - mSeekFraction;
            }
        }
        mStarted = true;
        mPaused = false;
        mRunning = false;
        mAnimationEndRequested = false;
       // 处理动画 开始时候恢复到第一帧
        mLastFrameTime = -1;
        mFirstFrameTime = -1;
        mStartTime = -1;
        addAnimationCallback(0);
				
  			// 动画接口会调
        if (mStartDelay == 0 || mSeekFraction >= 0 || mReversing) {

            startAnimation();
            if (mSeekFraction == -1) {
     
                setCurrentPlayTime(0);
            } else {
                setCurrentFraction(mSeekFraction);
            }
        }
    }
```

首先看`target1`初始化动画分数,来服务于动画的播放进程,下面看几个参数的含义:

-  mReversing = playBackwards;  // 是否反转从后面开始播放
- mSeekFraction	// 表示动画要跳到的播放时间点(0~1)

`target2`,`    addAnimationCallback(0);`是将anim加入队列中

```java
private void addAnimationCallback(long delay) {
    if (!mSelfPulse) {
        return;
    }
    getAnimationHandler().addAnimationFrameCallback(this, delay);
}
 public void addAnimationFrameCallback(final AnimationFrameCallback callback, long delay) {
        if (mAnimationCallbacks.size() == 0) {
            getProvider().postFrameCallback(mFrameCallback);
        }
        if (!mAnimationCallbacks.contains(callback)) {
            mAnimationCallbacks.add(callback);
        }

        if (delay > 0) {
            mDelayedCallbackStartTime.put(callback, (SystemClock.uptimeMillis() + delay));
        }
    }
```

接着看`target3`这里是设置动画的回调时机:这是核心代码

```java
if (mStartDelay == 0 || mSeekFraction >= 0 || mReversing) {
    // 开始动画会调
    startAnimation();
  	// 以下均是update的会调 10ms/次
    if (mSeekFraction == -1) {
        // 如果跳转点为-1,从头播放
        setCurrentPlayTime(0);
    } else {
      	// 根据seek分数播放
        setCurrentFraction(mSeekFraction);
    }
}
```

#### 5.开始动画`.startAnimation()`

首先看:`startAnimation();`动画开始时候会调用这里

```java
// 调用开始动画,必须在UI线程调用
private void startAnimation() {
    if (Trace.isTagEnabled(Trace.TRACE_TAG_VIEW)) {
        Trace.asyncTraceBegin(Trace.TRACE_TAG_VIEW, getNameForTrace(),
                System.identityHashCode(this));
    }

    mAnimationEndRequested = false;
  	// 初始化动画  -- target1
    initAnimation();
    mRunning = true;
    if (mSeekFraction >= 0) {
        mOverallFraction = mSeekFraction;
    } else {
        mOverallFraction = 0f;
    }
    if (mListeners != null) {
      	// 回调开始动画接口
        notifyStartListeners();
    }
}
```

首先看初始化动画`.initAnimation()`

```java
@CallSuper
void initAnimation() {
    if (!mInitialized) {
        int numValues = mValues.length;
        for (int i = 0; i < numValues; ++i) {
            mValues[i].init();
        }
        mInitialized = true;
    }
}
```

这里唯一的逻辑点就是`mValues[i].init()`

那么`mValues`是什么呢? `PropertyValuesHolder[] mValues;`是一个PropertyValuesHolder类的数组

我们直接看`PropertyValuesHolder.init()`:

```java
void init() {
    if (mEvaluator == null) {
        // We already handle int and float automatically, but not their Object
        // equivalents
        mEvaluator = (mValueType == Integer.class) ? sIntEvaluator :
                (mValueType == Float.class) ? sFloatEvaluator :
                null;
    }
    if (mEvaluator != null) {
        // KeyframeSet knows how to evaluate the common types - only give it a custom
        // evaluator if one has been set on this class
        mKeyframes.setEvaluator(mEvaluator);
    }
}
```

就是设置了一个估值器进行动画进度分数计算而已

#### 6. 更新动画`setCurrentPlayTime`

```java
public void setCurrentPlayTime(long playTime) {
    float fraction = mDuration > 0 ? (float) playTime / mDuration : 1;
    setCurrentFraction(fraction);
}

public void setCurrentFraction(float fraction) {
  			//如果没有初始化 则初始化动画加入估值器
        initAnimation();
  			// 设定动画进度分数
        fraction = clampFraction(fraction);
        mStartTimeCommitted = true; // do not allow start time to be compensated for jank
        if (isPulsingInternal()) {
            long seekTime = (long) (getScaledDuration() * fraction);
            long currentTime = AnimationUtils.currentAnimationTimeMillis();

            mStartTime = currentTime - seekTime;
        } else {

            mSeekFraction = fraction;
        }
        mOverallFraction = fraction;
  			// 根据是否反转 进行最终进度设定
        final float currentIterationFraction = getCurrentIterationFraction(fraction, mReversing);
  			// 核心逻辑
        animateValue(currentIterationFraction);
    }
```

code中已经进行了详细的标注,这里直接看核心逻辑`animateValue`

```java
@CallSuper
void animateValue(float fraction) {
    fraction = mInterpolator.getInterpolation(fraction);
    mCurrentFraction = fraction;
    int numValues = mValues.length;
    for (int i = 0; i < numValues; ++i) {
      	// 计算value -- target1
        mValues[i].calculateValue(fraction);
    }
    if (mUpdateListeners != null) {
        int numListeners = mUpdateListeners.size();
        for (int i = 0; i < numListeners; ++i) {
          	// 每10ms一次更新动画 -- target2
            mUpdateListeners.get(i).onAnimationUpdate(this);
        }
    }
}
```

`

target1`同样移步`PropertyValuesHolder`看其计算过程:

```java
void calculateValue(float fraction) {
    Object value = mKeyframes.getValue(fraction);
  	// 转换类型
    mAnimatedValue = mConverter == null ? value : mConverter.convert(value);
}
```

看下 `getValue的实现`

```java
@Override
public int getIntValue(float fraction) {
    if (fraction <= 0f) {
        final IntKeyframe prevKeyframe = (IntKeyframe) mKeyframes.get(0);
        final IntKeyframe nextKeyframe = (IntKeyframe) mKeyframes.get(1);
        int prevValue = prevKeyframe.getIntValue();
        int nextValue = nextKeyframe.getIntValue();
        float prevFraction = prevKeyframe.getFraction();
        float nextFraction = nextKeyframe.getFraction();
        final TimeInterpolator interpolator = nextKeyframe.getInterpolator();
        if (interpolator != null) {
            fraction = interpolator.getInterpolation(fraction);
        }
        float intervalFraction = (fraction - prevFraction) / (nextFraction - prevFraction);
        return mEvaluator == null ?
                prevValue + (int)(intervalFraction * (nextValue - prevValue)) :
                ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).
                        intValue();
    } else if (fraction >= 1f) {
        final IntKeyframe prevKeyframe = (IntKeyframe) mKeyframes.get(mNumKeyframes - 2);
        final IntKeyframe nextKeyframe = (IntKeyframe) mKeyframes.get(mNumKeyframes - 1);
        int prevValue = prevKeyframe.getIntValue();
        int nextValue = nextKeyframe.getIntValue();
        float prevFraction = prevKeyframe.getFraction();
        float nextFraction = nextKeyframe.getFraction();
        final TimeInterpolator interpolator = nextKeyframe.getInterpolator();
        if (interpolator != null) {
            fraction = interpolator.getInterpolation(fraction);
        }
        float intervalFraction = (fraction - prevFraction) / (nextFraction - prevFraction);
        return mEvaluator == null ?
                prevValue + (int)(intervalFraction * (nextValue - prevValue)) :
                ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).intValue();
    }
    IntKeyframe prevKeyframe = (IntKeyframe) mKeyframes.get(0);
    for (int i = 1; i < mNumKeyframes; ++i) {
        IntKeyframe nextKeyframe = (IntKeyframe) mKeyframes.get(i);
        if (fraction < nextKeyframe.getFraction()) {
            final TimeInterpolator interpolator = nextKeyframe.getInterpolator();
            float intervalFraction = (fraction - prevKeyframe.getFraction()) /
                (nextKeyframe.getFraction() - prevKeyframe.getFraction());
            int prevValue = prevKeyframe.getIntValue();
            int nextValue = nextKeyframe.getIntValue();
            // Apply interpolator on the proportional duration.
            if (interpolator != null) {
                intervalFraction = interpolator.getInterpolation(intervalFraction);
            }
            return mEvaluator == null ?
                    prevValue + (int)(intervalFraction * (nextValue - prevValue)) :
                    ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).
                            intValue();
        }
        prevKeyframe = nextKeyframe;
    }
    // shouldn't get here
    return ((Number)mKeyframes.get(mNumKeyframes - 1).getValue()).intValue();
}
```

fraction <= 0f就是第一个时间点和第二个时间点
fraction >= 1f就是最后一个时间点和倒数第二个时间点
大体的value值获取:
首先在ValueAnimator的ofInt初始化阶段会把fraction和value以key–value的形式存入Keyframe中然后在这里获取,通过插值器根据不同的要求获取fraction,然后估值器返回value
这样在会调接口:
ValueAnimator.AnimatorUpdateListener()—onAnimationUpdate(ValueAnimator animation) 通过int currentValue = (Integer) animation.getAnimatedValue();来获取value进行不同速率的动画实现


这里的`fraction`可以看下`setupValue`,这里就是anim的set方法,最终会`setAnimatedValue`

接着看` mUpdateListeners.get(i).onAnimationUpdate(this);`

这里调用动画更新的回调

```java
public static interface AnimatorUpdateListener {
    /**
     * <p>Notifies the occurrence of another frame of the animation.</p>
     *
     * @param animation The animation which was repeated.
     */
    void onAnimationUpdate(ValueAnimator animation);

}
```

