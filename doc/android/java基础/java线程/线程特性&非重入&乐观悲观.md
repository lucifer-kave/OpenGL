#### 1.并发编程

并发程序要正确的执行,必须保证具备原子性,可见性以及有序性



- 原子性:一个操作或者多个操作要么全部执行且执行过程不能被中断,要么不执行
  - 可以通过**Synchronized**和**Lock**实现原子性,因为**Synchronized**和**Lock**能够保证任一时刻只有一个线程访问该代码块

- 可见性:多个线程修改同一个共享变量时,一个线程修改后,其他线程能马上获得修改后的值
  - java提供了**volatile关键字**保证可见性
  - **Synchronized**和**Lock**也可以保证可见性,在加锁时其他线程无法访问共享资源

- 有序性:程序执行的顺序按照代码的先后顺序执行
  - **volatile关键字**来保证一定的"有序性"

#### 2.重入锁和非重入锁

- 不可重入锁 : 若当前线程执行某个方法已经获取了该锁,那么在方法中尝试在再次获取锁 时,就会获取不到然后阻塞
- 重入:就是同一线程可以无限重入他的锁

所以重入和非重入是相对于线程和当前线程锁而言的

#### 3. 实现重入锁和非重入锁

调用code:

```java
private void print() throws InterruptedException {
    lock.lock();
    doAdd();
    lock.unlock();

}

private void doAdd() throws InterruptedException {

    lock.lock();
    // do some thing
    lock.unlock();
}
```

**非重入锁**

```java
public class Lock {

    private boolean isLocked = false;
  	// 不管是不是同一线程只要拿到锁就不会释放,所以同意线程去重复lock时候会造成死锁
    public void lock() throws InterruptedException {
        while (isLocked){
            wait();
        }
        isLocked = true;
    }

    public void unlock(){
        isLocked = false;
        notify();
    }


}
```

**重入锁**

```java
public class ReetLock {

    private boolean isLocked = false;
    Thread lockedBy = null;
    int lockedCount = 0;
		// 当前线程可以重入  不过lockedCount要计数
    public synchronized void lock() throws InterruptedException {
        Thread thread = Thread.currentThread();
        while (isLocked  &&  lockedBy != thread){
            wait();
        }
        isLocked = true;
        lockedCount++;
        lockedBy = thread;
    }

    public synchronized void unlock(){
        if (Thread.currentThread() == this.lockedBy){
            lockedCount--;
            if (lockedCount  == 0){
                isLocked = false;
                notify();
            }
        }

    }

}
```

#### 4. 乐观锁和悲观锁

- 乐观锁: 每次去拿数据的时候认为别人不会修改,所以不会上锁,但是在更新的时候会判断一下此期间别人有没有会去更新这个数据
  - 使用场景:版本号或者时间错控制,适用于多读少写的场景

- 悲观锁: 每次去拿数据的时候都认为别人会修改,所以每次在拿数据的时候都会上锁,这样别人想拿这个数据就会block知道它拿到锁
  - DB的行锁,表锁等,适用于数据一致性比较高的场景



##### 4.1 场景

什么时候使用乐观锁?

资源提交冲突,其他使用方需要重新读取资源,会增加读的次数,但是可以面对高并发场景,前提是出现提交失败用户是可以 接收的.因此一般乐观锁只用在 高并发,多读少写的场景

其中:GIT,SVN,CVS等代码版本控制管理器 ,就是一个乐观锁使用很好的场景,例如A,B程序员,同时从SVN服务器上下载了code.html文件 ,当A完成提交之后,此时 B再去提交,那么会报版本冲突,此时B需要进行版本处理合并后,再提交到服务器.这其实就是乐观锁的实现全过程.如果此时使用的是悲观锁,那么就意味着所有程序员都必须一个个等待操作提交完,才能访问文件,这是难以接受的.

什么时候使用悲观锁?

如果通过悲观锁锁定一个资源,那么其他需要操作该资源的使用方,只能等待知道锁被释放,好处在于可以减少并发,但是当并发量非常大的时候,由于锁资源消耗,并且可能锁定时间过长,容易导致系统性能下降,资源 消耗严重.因此一般 我们可以在并发量不是很大,并且出现 并发情况导致的异常用户和系统都难以接收的情况下,会选择悲观锁进行.



