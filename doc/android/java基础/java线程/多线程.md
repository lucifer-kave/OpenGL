线程的方法：sleep，不释放锁；wait，释放锁；join可以控制线程的执行顺序。yield可以礼让，需要按优先级排

Lock和trylock，lockInterruptibly

lock获取锁，如果该锁没有被获取，立即获取，计数加1，如果是当前线程获取的，立即获取锁，计数加1；如果不是当前线程，当前线程休眠，锁保持计数为1；

lockInterruptibly跟lock差不多，只是lock不相应中断操作，lockInterruptibly响应中断操作。

trylock如果没有被其他线程获取，立即获取锁，即使这个锁设置了公平策略，不管有没有其他等待获取锁的线程，立即获取，可以保持公平策略trylock(0， TimeUnit.SECONDS)；获取不到锁就返回false

CountDownLatch 需要次数执行完才会调用await后面的代码；一个线程要等别的线程执行完才执行；

CyclicBarrier 需要一组线程同步到一个状态之后一起执行；

#### 重量锁、轻量锁、偏向锁

偏向锁：多线程竞争的时候会有撤销偏向锁的操作，会在`safepoint`中去查看偏向的线程是否还存活,如果存活且还在同步块中则将锁升级为轻量级锁，原偏向的线程继续拥有锁，当前线程则走入到锁升级的逻辑里；如果偏向的线程已经不存活或者不在同步块中，则将对象头的`mark word`改为无锁状态（unlocked），之后再升级为轻量级锁。**偏向锁的撤销需要`safepoint`，是一次gc stop the world，消耗性能**

**线程上下文切换**：线程的执行是cpu调度的，上下文就是指保持状态到恢复执行就是一次上下文切换

**让步式上下文切换**：是主动释放cpu资源，抢占式上下文切换：就是cpu分配的时间不够用，被迫保存状态

活锁：线程并没有阻塞，由于不满足某些条件，一直在重试，然后失败，活锁是有可能解开的；例如从队列取值不符合要求就放回队列，一直不符合要求就无限循环就活锁了。

死锁：1.某个时间独占资源；2.请求新的资源产生了阻塞，对已有的资源不释放；3.不能强行剥夺；4.循环等待资源

饥饿：线程无法获取资源，导致无法执行（优先级低）

*setUncaughtExceptionHandler*可以捕获线程运行时异常。

线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。

####线程池

核心线程和普通线程的区别：核心线程idle的时候不会回收，普通线程会回收；allowCoreThreadTimeOut可以设置核心线程是否alive当idle的时候。

submit() :返回Future；execute()：没有返回值

线程复用是通过runWorker里面循环获取队列里面的worker

