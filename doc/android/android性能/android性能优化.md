#### 1. app卡顿定位

* 内存抖动可能会引起频繁gc，gc会引起主线程阻塞，造成卡顿
* 通过设置Handler日志查看主线程Handler消息的执行时间来模糊定位
* 可以通过屏幕刷新Choreographer

#### 2.对象池的应用

目的是为了避免频繁的创建和回收对象，从而保持内存的稳定。在优化内存时，对象池是一个非常重要的武器。

* 对象池的大小。对象池的目的是用于在内存中缓存对象，但是不能所有的对象都缓存，如果所有的对象都缓存，无疑对内存也是一个非常巨大的损耗。所以每个对象池都需要设置一个大小，每个对象池都有默认的大小的，需要在调用构建方法的时候就设置大小
* 抽象 & 泛型。为了通用性，对象池一般都会先定义一个接口或者抽象基类，而且是泛型的接口或者基类，`Pool<T>`、`LruPoolStrategy`、`BaseKeyPool<T extends Poolable>` 就是最好的例证，这两点有什么好处呢？接口或者抽象基类有利于扩展，实现不同的存放、获取的方法，而泛型则可以存储不同的对象
* 抽象方法定义。对象池一般有三个动作存放 put、获取 get 以及新建 create，所以在接口或者抽象基类中一般包含这三个方法即可